{
  "version": 1.1,
  "tags": [
    {
      "name": "ten-counter",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-app",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "bootstrap-button",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-collapsible",
      "description": "`CustomCollapsible` is a class for custom collapsible element (`<custom-collapsible>` web component).\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **toggle()** - Wait until transition is finished.\n- **_showAnimation({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _)** - Trigger show animation and wait for transition to be finished.\n- **_hideAnimation({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _)** - Trigger hide animation and wait for transition to be finished.\n- **_waitForTransition({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _): _Promise<void>_** - Wait until the transition event is finished.\n- **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.\n- **show()** - Show extra content.\n- **hide()** - Hide extra content.",
      "attributes": [],
      "references": []
    },
    {
      "name": "slots-dialog-content",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **close-overlay** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "styled-dialog-content",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **close-overlay** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-selection-display",
      "description": "Renders the wrapper containing the textbox that triggers the listbox with filtered options.\nOptionally, shows 'chips' that indicate the selection.\nShould be considered an internal/protected web component to be used in conjunction with\nLionCombobox\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null, null]
    },
    {
      "name": "intl-input-tel-dropdown",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **_isEmpty(modelValue: _string_): _boolean_** - Used for Required validation and computation of interaction states.\nWe need to override this, because we prefill the input with the region code (like +31), but for proper UX,\nwe don't consider this as having interaction state `prefilled`\n- **_repropagationCondition(target: _FormControlHost_)** - Usually, we don't use composition in regular LionFields (non choice-groups). Here we use a LionSelect(Rich) inside.\nWe don't want to repropagate any children, since an Application Developer is not concerned with these internals (see repropate logic in FormControlMixin)\nAlso, we don't want to give (wrong) info to InteractionStateMixin, that will set the wrong interaction states based on child info.\nTODO: Make \"this._repropagationRole !== 'child'\" the default for FormControlMixin\n(so that FormControls used within are never repropagated for LionFields)\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setActiveRegion(newValue: _RegionCode|undefined_)** - Protected setter for activeRegion, only meant for subclassers\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **formatter(modelValue: _string_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **parser(viewValue: _string_): _string_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **preprocessor(viewValue: _string_, { currentCaretIndex, prevViewValue }, options: _@param {string} options.prevViewValue\n   * @param {number} options.currentCaretIndex\n   * _): _{ viewValue: string; caretIndex: number; } | undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_reflectBackOn(): _boolean_** - Do not reflect back .formattedValue during typing (this normally wouldn't happen when\nFormatMixin calls _calculateValues based on user input, but for LionInputTel we need to\ncall it on .activeRegion change)\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "h-region-code-table",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-determinate-progress-bar",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-indeterminate-progress-spinner",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.",
      "attributes": [],
      "references": []
    },
    {
      "name": "intl-option",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n- **active-changed** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "intl-select-invoker",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_noSelectionTemplate(): _TemplateResult_** - To be overriden for a placeholder, used when `hasNoDefaultSelected` is true on the select rich",
      "attributes": [],
      "references": []
    },
    {
      "name": "intl-separator",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "intl-select-rich",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **blur** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_getCheckedElements()** - In the select disabled options are still going to a possible value for example\nwhen prefilling or programmatically setting it.\n- **_noDefaultSelectedInheritsWidth()** - With no selected element, we should override the inheritsReferenceWidth in most cases.\nBy default, we will set it to 'min', and then set it back to what it was initially when\nsomething is selected.\nAs a subclasser you can override this behavior.\n- **_alignInvokerWidth()** - Align invoker width with content width\nMake sure display is not set to \"none\" while calculating the content width\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "lea-tab-panel",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lea-tab",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lea-tabs",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **selected-changed** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "extension-counter",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "source-counter",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "google-option",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n- **active-changed** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "google-combobox",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties)** - Empty pending queue in order to guarantee order independence\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **parser(value: _string|string[]_): _*_** - Converts viewValue to modelValue\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **__unsyncCheckedIndexOnInputChange()** - When textbox value doesn't match checkedIndex anymore, update accordingly...\n- **matchCondition(option: _LionOption_, textboxValue: _string_)** - When the preconfigurable `match-mode` conditions are not sufficient,\none can define a custom matching function.\n- **_getTextboxValueFromOption(option: _LionOption_): _string_** - Return the value to be used for the input value\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_handleAutocompletion()** - Handles autocompletion. This entails:\n- list: shows a list on keydown character press\n- filter: filters list of potential matches according to matchmode or provided matchCondition\n- focus: automatically focuses closest match (makes it the activedescendant)\n- check: automatically checks/selects closest match when selection-follows-focus is enabled\n(this is the default configuration)\n- complete: completes the textbox value inline (the 'missing characters' will be added as\nselected text)\n- **_autoSelectCondition()** - When this condition is false, an end user will have to manually select a suggested\noption from the list (by default when autocomplete is 'none' or 'list').\nFor autocomplete 'both' or 'inline', it will automatically select on a match.\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "gh-button",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "gh-option",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n- **active-changed** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "gh-combobox",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **firstUpdated(changedProperties)** - Empty pending queue in order to guarantee order independence\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **parser(value: _string|string[]_): _*_** - Converts viewValue to modelValue\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **__unsyncCheckedIndexOnInputChange()** - When textbox value doesn't match checkedIndex anymore, update accordingly...\n- **matchCondition(option: _LionOption_, textboxValue: _string_)** - When the preconfigurable `match-mode` conditions are not sufficient,\none can define a custom matching function.\n- **_getTextboxValueFromOption(option: _LionOption_): _string_** - Return the value to be used for the input value\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_handleAutocompletion()** - Handles autocompletion. This entails:\n- list: shows a list on keydown character press\n- filter: filters list of potential matches according to matchmode or provided matchCondition\n- focus: automatically focuses closest match (makes it the activedescendant)\n- check: automatically checks/selects closest match when selection-follows-focus is enabled\n(this is the default configuration)\n- complete: completes the textbox value inline (the 'missing characters' will be added as\nselected text)\n- **_autoSelectCondition()** - When this condition is false, an end user will have to manually select a suggested\noption from the list (by default when autocomplete is 'none' or 'list').\nFor autocomplete 'both' or 'inline', it will automatically select on a match.\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "md-option",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n- **active-changed** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "md-combobox",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **parser(value: _string|string[]_): _*_** - Converts viewValue to modelValue\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **__unsyncCheckedIndexOnInputChange()** - When textbox value doesn't match checkedIndex anymore, update accordingly...\n- **matchCondition(option: _LionOption_, textboxValue: _string_)** - When the preconfigurable `match-mode` conditions are not sufficient,\none can define a custom matching function.\n- **_getTextboxValueFromOption(option: _LionOption_): _string_** - Return the value to be used for the input value\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_handleAutocompletion()** - Handles autocompletion. This entails:\n- list: shows a list on keydown character press\n- filter: filters list of potential matches according to matchmode or provided matchCondition\n- focus: automatically focuses closest match (makes it the activedescendant)\n- check: automatically checks/selects closest match when selection-follows-focus is enabled\n(this is the default configuration)\n- complete: completes the textbox value inline (the 'missing characters' will be added as\nselected text)\n- **_autoSelectCondition()** - When this condition is false, an end user will have to manually select a suggested\noption from the list (by default when autocomplete is 'none' or 'list').\nFor autocomplete 'both' or 'inline', it will automatically select on a match.\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "md-input",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "wa-option",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n- **active-changed** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "wa-combobox",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **parser(value: _string|string[]_): _*_** - Converts viewValue to modelValue\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **__unsyncCheckedIndexOnInputChange()** - When textbox value doesn't match checkedIndex anymore, update accordingly...\n- **matchCondition(option: _LionOption_, textboxValue: _string_)** - When the preconfigurable `match-mode` conditions are not sufficient,\none can define a custom matching function.\n- **_getTextboxValueFromOption(option: _LionOption_): _string_** - Return the value to be used for the input value\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_handleAutocompletion()** - Handles autocompletion. This entails:\n- list: shows a list on keydown character press\n- filter: filters list of potential matches according to matchmode or provided matchCondition\n- focus: automatically focuses closest match (makes it the activedescendant)\n- check: automatically checks/selects closest match when selection-follows-focus is enabled\n(this is the default configuration)\n- complete: completes the textbox value inline (the 'missing characters' will be added as\nselected text)\n- **_autoSelectCondition()** - When this condition is false, an end user will have to manually select a suggested\noption from the list (by default when autocomplete is 'none' or 'list').\nFor autocomplete 'both' or 'inline', it will automatically select on a match.\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "h-output",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-el-using-overlaymixin",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-overlay",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-close-button",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-overlay-backdrop",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-overlay-el",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-overlay-positioning",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "umbrella-form",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-app",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-app",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "demo-app",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "# <lion-accordion> webcomponent\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-button",
      "description": "Use LionButton (or LionButtonReset|LionButtonSubmit) when there is a need to extend HTMLButtonElement.\nIt allows to create complex shadow DOM for buttons needing this. Think of:\n- a material Design button that needs a JS controlled ripple\n- a LionSelectRich invoker that needs a complex shadow DOM structure\n(for styling/maintainability purposes)\n- a specialized button (for instance a primary button or icon button in a Design System) that\nneeds a simple api: `<my-button>text</my-button>` is always better than\n`<button class=\"my-button\"><div class=\"my-button__container\">text</div><button>`\n\nIn other cases, whenever you can, still use native HTMLButtonElement (`<button>`).\n\nNote that LionButton is meant for buttons with type=\"button\". It's cleaner and more\nlightweight than LionButtonReset and LionButtonSubmit, which should only be considered when native\n`<form>` support is needed:\n- When type=\"reset|submit\" should be supported, use LionButtonReset.\n- When implicit form submission should be supported on top, use LionButtonSubmit.\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-button-reset",
      "description": "This adds functionality for form buttons (type 'submit' and 'reset').\nIt allows to submit or reset a <form> by spawning a click on a temporrary native button inside\nthe form.\nUse LionButtonSubmit when implicit form submission should be supported as well.\n\nFunctionality in this button is not purely for type=\"reset\", also for type=\"submit\".\nFor mainainability purposes the submit functionality is part of LionButtonReset\n(it needs the same logic).\nLionButtonReset could therefore actually be considered as 'LionButtonForm' (without the\nimplicit form submission logic), but LionButtonReset is an easier to grasp name for\nApplication Developers: for reset buttons, always use LionButtonReset, for submit\nbuttons always use LionButtonSubmit.\n\n\n---\n\n\n\n\n### **Methods:**\n - **__clickDelegationHandler(ev: _Event_): _Promise<void>_** - Delegate click, by flashing a native button as a direct child\nof the form, and firing click on this button. This will fire the form submit\nwithout side effects caused by the click bubbling back up to lion-button.",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-button-submit",
      "description": "Contains all the funcionaility of LionButton and LionButtonReset. On top of that it\nsupports implicit form submission.\n\nUse when:\n- the Application Developer should be able to switch types between 'submit'|'reset'|'button'\n(this is similar to how native HTMLButtonElement works)\n- a submit button with native form support is needed\n\n\n---\n\n\n\n\n### **Methods:**\n - **__clickDelegationHandler(ev: _Event_): _Promise<void>_** - Delegate click, by flashing a native button as a direct child\nof the form, and firing click on this button. This will fire the form submit\nwithout side effects caused by the click bubbling back up to lion-button.",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-calendar",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **user-selected-date-changed** - undefined\n\n### **Methods:**\n - **initCentralDate()** - This exposes an interface for datepickers that want to\nreinitialize when calendar is opened\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-checkbox",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-checkbox-group",
      "description": "A wrapper around multiple checkboxes\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-checkbox-indeterminate",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-collapsible",
      "description": "`LionCollapsible` is a class for custom collapsible element (`<lion-collapsible>` web component).\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.\n- **show()** - Show extra content.\n- **hide()** - Hide extra content.\n- **toggle()** - Toggle the current(opened/closed) state.\n- **_showAnimation(opts: _Object_)** - Show animation implementation in sub-classer.\n- **_hideAnimation(opts: _Object_)** - Hide animation implementation in sub-classer.",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-combobox",
      "description": "LionCombobox: implements the wai-aria combobox design pattern and integrates it as a Lion\nFormControl\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **parser(value: _string|string[]_): _*_** - Converts viewValue to modelValue\n- **__unsyncCheckedIndexOnInputChange()** - When textbox value doesn't match checkedIndex anymore, update accordingly...\n- **matchCondition(option: _LionOption_, textboxValue: _string_)** - When the preconfigurable `match-mode` conditions are not sufficient,\none can define a custom matching function.\n- **_getTextboxValueFromOption(option: _LionOption_): _string_** - Return the value to be used for the input value\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **_handleAutocompletion()** - Handles autocompletion. This entails:\n- list: shows a list on keydown character press\n- filter: filters list of potential matches according to matchmode or provided matchCondition\n- focus: automatically focuses closest match (makes it the activedescendant)\n- check: automatically checks/selects closest match when selection-follows-focus is enabled\n(this is the default configuration)\n- complete: completes the textbox value inline (the 'missing characters' will be added as\nselected text)\n- **_autoSelectCondition()** - When this condition is false, an end user will have to manually select a suggested\noption from the list (by default when autocomplete is 'none' or 'list').\nFor autocomplete 'both' or 'inline', it will automatically select on a match.\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "can-be-disabled",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "can-be-disabled-with-tab-index",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "scoped-el",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-dialog",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-drawer",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.\n- **_showAnimation({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _)** - Trigger show animation and wait for transition to be finished.\n- **_hideAnimation({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _)** - Trigger hide animation and wait for transition to be finished.\n- **_waitForTransition({ contentNode }, options: _@param {HTMLElement} options.contentNode\n   * _): _Promise<void>_** - Wait until the transition event is finished.\n- **show()** - Show extra content.\n- **hide()** - Hide extra content.\n- **toggle()** - Toggle the current(opened/closed) state.",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-fieldset",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Gets a keyed be name object for requested property (like modelValue/serializedValue)\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-form",
      "description": "LionForm: form wrapper providing extra features and integration with lion-field elements.\n\n\n---\n\n\n\n\n### **Events:**\n - **submit** - undefined\n- **reset** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Gets a keyed be name object for requested property (like modelValue/serializedValue)\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-field",
      "description": "`LionField`: wraps <input>, <textarea>, <select> and other interactable elements.\nAlso it would follow a nice hierarchy: lion-form -> lion-fieldset -> lion-field\n\nNote: We don't support placeholders, because we have a helper text and\nplaceholders confuse the user with accessibility needs.\n\nPlease see the docs for in depth information.\n\n\n---\n\n\n\n\n### **Events:**\n - **user-input-changed** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.",
      "attributes": [],
      "references": []
    },
    {
      "name": "tagString",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-register** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "sb-action-logger",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **log(content: _string_)** - Renders the passed content as a node, and appends it to the logger\nOnly supports simple values, will be interpreted to a String\nE.g. an Object will become '[object Object]'\n- **_logTemplate(content: _string_): _TemplateResult_** - Protected getter that returns the template of a single log",
      "attributes": [],
      "references": []
    },
    {
      "name": "sb-locale-switcher",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-icon",
      "description": "Custom element for rendering SVG icons\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-input",
      "description": "LionInput: extension of lion-field with native input element in place and user friendly API.\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-date",
      "description": "`LionInputDate` has a .modelValue of type Date. It parses, formats and validates based\non locale.\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **serializer(modelValue: _Date_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(serializedValue: _string_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-amount",
      "description": "`LionInputAmount` is a class for an amount custom form element (`<lion-input-amount>`).\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_connectSlotMixin()** - Upon connecting slot mixin, we should check if\nthe required slot was created by the slot mixin,\nand if so, we should execute the currency changed flow\nwhich evaluates whether the slot node should be\nremoved for invalid currencies\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-input-amount",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **user-selected-date-changed** - undefined\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **initCentralDate()** - This exposes an interface for datepickers that want to\nreinitialize when calendar is opened",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-datepicker",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_overlayTemplate()** - Defining this overlay as a templates from OverlayMixin\nthis is our source to give as .contentNode to OverlayController.\nImportant: do not change the name of this method.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_calendarTemplate()** - Subclassers can replace this with their custom extension of\nLionCalendar, like `<my-calendar id=\"calendar\"></my-calendar>`\n- **_invokerTemplate()** - Subclassers can replace this with their custom extension invoker,\nlike `<my-button><calendar-icon></calendar-icon></my-button>`\n- **_invokerIconTemplate()** - Subclassers can replace this with their custom extension invoker icon\n- **_defineOverlayConfig(): _Object_** - Overrides arrow and keepTogether modifier to be enabled,\nand adds onCreate and onUpdate hooks to sync from popper state\n- **_onCalendarOverlayOpened()** - Lifecycle callback for subclassers\n- **_onCalendarUserSelectedChanged({ target: { selectedDate } }, opts: _{ target: { selectedDate: Date }}_)** - Triggered when a user selects a date from the calendar overlay\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **__getSyncDownValue(modelValue: _?_): _Date | undefined_** - The LionCalendar shouldn't know anything about the modelValue;\nit can't handle Unparseable dates, but does handle 'undefined'\n- **__syncDisabledDates(validators: _Validator[]_)** - Validators contain the information to synchronize the input with\nthe min, max and enabled dates of the calendar.\n- **_onValidatorUpdated(e: _Event|CustomEvent_, metaData: _{validator: Validator}_)** - Responsible for listening param change event and\nsync the calendar dates with the updated validator params\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **serializer(modelValue: _Date_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(serializedValue: _string_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "tagName",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_defineOverlayConfig(): _OverlayConfig_** - Overrides arrow and keepTogether modifier to be enabled,\nand adds onCreate and onUpdate hooks to sync from popper state\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_overlayTemplate()** - Defining this overlay as a templates from OverlayMixin\nthis is our source to give as .contentNode to OverlayController.\nImportant: do not change the name of this method.\n- **_calendarTemplate()** - Subclassers can replace this with their custom extension of\nLionCalendar, like `<my-calendar id=\"calendar\"></my-calendar>`\n- **_invokerTemplate()** - Subclassers can replace this with their custom extension invoker,\nlike `<my-button><calendar-icon></calendar-icon></my-button>`\n- **_invokerIconTemplate()** - Subclassers can replace this with their custom extension invoker icon\n- **_onCalendarOverlayOpened()** - Lifecycle callback for subclassers\n- **_onCalendarUserSelectedChanged({ target: { selectedDate } }, opts: _{ target: { selectedDate: Date }}_)** - Triggered when a user selects a date from the calendar overlay\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **__getSyncDownValue(modelValue: _?_): _Date | undefined_** - The LionCalendar shouldn't know anything about the modelValue;\nit can't handle Unparseable dates, but does handle 'undefined'\n- **__syncDisabledDates(validators: _Validator[]_)** - Validators contain the information to synchronize the input with\nthe min, max and enabled dates of the calendar.\n- **_onValidatorUpdated(e: _Event|CustomEvent_, metaData: _{validator: Validator}_)** - Responsible for listening param change event and\nsync the calendar dates with the updated validator params\n- **serializer(modelValue: _Date_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(serializedValue: _string_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-input-amount",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **user-selected-date-changed** - undefined\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **initCentralDate()** - This exposes an interface for datepickers that want to\nreinitialize when calendar is opened",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-calendar-overlay-frame",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-email",
      "description": "LionInputEmail: extension of lion-input\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-file",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **file-list-changed** - undefined\n- **file-removed** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **user-input-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **parser(v: _string_, opts: _FormatOptions_): _InputFile[]_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _InputFile[]_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event\n- **_onClick(ev: _Event_)** - Clear _inputNode.value to make sure onChange is called even for duplicate files\n- **_processFiles(selectedFiles: _InputFile[]_)** - Runs on drag or change event\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. In case of the input-file we don't want\nthis sync to happen, since the view value is already correct.\n- **_isEmpty(modelValue: _any_): _boolean_** - Helper method for the mutually exclusive Required Validator\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-selected-file-list",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **file-remove-requested** - undefined\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-iban",
      "description": "`LionInputIban` is a class for an IBAN custom form element (`<lion-input-iban>`).\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-range",
      "description": "LionInputRange: extension of lion-input.\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-stepper",
      "description": "`LionInputStepper` is a class for custom input-stepper element (`<lion-input-stepper>` web component).\n\n\n---\n\n\n\n\n### **Events:**\n - **undefined** - undefined\n- **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_onChange(ev: _Event=_)** - Toggle +/- buttons on change\n- **_decrementorSignTemplate(): _String|TemplateResult_** - Get the decrementor button sign template\n- **_incrementorSignTemplate(): _String|TemplateResult_** - Get the incrementor button sign template\n- **_decrementorTemplate(): _TemplateResult_** - Get the increment button template\n- **_incrementorTemplate(): _TemplateResult_** - Get the decrement button template\n- **_onLeaveButton()** - Redispatch leave event on host when catching leave event\non the incrementor and decrementor button.\n\nThis redispatched leave event will be caught by\nInteractionStateMixin to set \"touched\" state to true.\n\nInteracting with the buttons is \"user interactions\"\nthe same way as focusing + blurring the field (native input)\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-tel",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_setActiveRegion(newValue: _RegionCode|undefined_)** - Protected setter for activeRegion, only meant for subclassers\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **formatter(modelValue: _string_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **parser(viewValue: _string_): _string_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **preprocessor(viewValue: _string_, { currentCaretIndex, prevViewValue }, options: _@param {string} options.prevViewValue\n   * @param {number} options.currentCaretIndex\n   * _): _{ viewValue: string; caretIndex: number; } | undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_reflectBackOn(): _boolean_** - Do not reflect back .formattedValue during typing (this normally wouldn't happen when\nFormatMixin calls _calculateValues based on user input, but for LionInputTel we need to\ncall it on .activeRegion change)\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-input-tel-dropdown",
      "description": "LionInputTelDropdown renders a dropdown like element next to the text field, inside the\nprefix slot. This could be a LionSelect, a LionSelectRich or a native select.\nBy default, the native `<select>` element is used for this, so that it's as lightweight as\npossible. Also, it doesn't need to be a `FormControl`, because it's purely a helper element\nto provide better UX: the modelValue (the text field) contains all needed info, since it's in\n`e164` format that contains all info (both region code and national phone number).\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _string_): _boolean_** - Used for Required validation and computation of interaction states.\nWe need to override this, because we prefill the input with the region code (like +31), but for proper UX,\nwe don't consider this as having interaction state `prefilled`\n- **_repropagationCondition(target: _FormControlHost_)** - Usually, we don't use composition in regular LionFields (non choice-groups). Here we use a LionSelect(Rich) inside.\nWe don't want to repropagate any children, since an Application Developer is not concerned with these internals (see repropate logic in FormControlMixin)\nAlso, we don't want to give (wrong) info to InteractionStateMixin, that will set the wrong interaction states based on child info.\nTODO: Make \"this._repropagationRole !== 'child'\" the default for FormControlMixin\n(so that FormControls used within are never repropagated for LionFields)\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded\n- **_setActiveRegion(newValue: _RegionCode|undefined_)** - Protected setter for activeRegion, only meant for subclassers\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **formatter(modelValue: _string_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **parser(viewValue: _string_): _string_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **preprocessor(viewValue: _string_, { currentCaretIndex, prevViewValue }, options: _@param {string} options.prevViewValue\n   * @param {number} options.currentCaretIndex\n   * _): _{ viewValue: string; caretIndex: number; } | undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **_reflectBackOn(): _boolean_** - Do not reflect back .formattedValue during typing (this normally wouldn't happen when\nFormatMixin calls _calculateValues based on user input, but for LionInputTel we need to\ncall it on .activeRegion change)\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": [null, null]
    },
    {
      "name": "lion-listbox",
      "description": "LionListbox: implements the wai-aria listbox design pattern and integrates it as a Lion\nFormControl\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-option",
      "description": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option\nCan be a child of datalist/select, or role=\"listbox\"\n\nElement gets state supplied externally, reflects this to attributes,\nenabling SubClassers to style based on those states\n\n\n---\n\n\n\n\n### **Events:**\n - **active-changed** - undefined\n- **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-register** - undefined\n\n### **Methods:**\n - **render(): _TemplateResult_** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_isEmpty()** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-options",
      "description": "LionOptions\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-pagination",
      "description": "`LionPagination` is a class for custom Pagination element (`<lion-pagination>` web component).\n\n\n---\n\n\n\n\n### **Methods:**\n - **next()** - Go next in pagination\n- **first()** - Go to first page\n- **last()** - Go to the last page\n- **goto(pageNumber: _number_)** - Go to the specific page\n- **previous()** - Go back in pagination\n- **_prevNextIconTemplate(label: _String_): _TemplateResult_** - Get previous or next button template.\nThis method can be overridden to apply customized template in wrapper.\n- **_prevNextButtonTemplate(label: _String_, pageNumber: _Number_, namespace: _String_): _TemplateResult_** - Get next or previous button template.\nThis method can be overridden to apply customized template in wrapper.\n- **_disabledButtonTemplate(label: _String_): _TemplateResult_** - Get disabled button template.\nThis method can be overridden to apply customized template in wrapper.\n- **_renderNavList(): _TemplateResult[]_** - Render navigation list\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded",
      "attributes": [],
      "references": []
    },
    {
      "name": "arrow-test",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_defineOverlayConfig(): _OverlayConfig_** - Overrides arrow and keepTogether modifier to be enabled,\nand adds onCreate and onUpdate hooks to sync from popper state\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-progress-indicator",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **updated(changedProperties: _PropertyValues_)** - Update aria labels on state change.\n- **performUpdate(): _Promise.<void>_** - hook into LitElement to only render once all translations are loaded",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-radio",
      "description": "Lion-radio can be used inside a lion-radio-group.\n\n<lion-radio-group name=\"radios\">\n  <label slot=\"label\">My Radio</label>\n  <lion-radio>\n    <label slot=\"label\">Male</label>\n  </lion-radio>\n  <lion-radio>\n    <label slot=\"label\">Female</label>\n  </lion-radio>\n</lion-radio-group>\n\nYou can preselect an option by setting marking an lion-radio checked.\n  Example:\n  <lion-radio checked>\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-radio-group",
      "description": "A wrapper around multiple radios.\n\n\n---\n\n\n\n\n### **Events:**\n - **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-select",
      "description": "LionSelect: wraps the native HTML element select\n\n<lion-select>\n  <label slot=\"label\">My Input</label>\n  <select slot=\"input\">\n   <option value=\"top\">top</option>\n   <option value=\"bottom\">bottom</option>\n  </select>\n</lion-select>\n\nYou can preselect an option by setting the property modelValue.\n  Example:\n    <lion-select .modelValue=\"${'<value of option 2>'}\">\n\nIt extends LionField so it inherits required and disabled.\n\nThe option element needs to be a direct child of the select element.\n\nYou cannot use interactive elements inside the options. Avoid very long names to\nfacilitate the understandability and perceivability for screen reader users. Sets of options\nwhere each option name starts with the same word or phrase can also significantly degrade\nusability for keyboard and screen reader users.\n\n\n---\n\n\n\n\n### **Events:**\n - **user-input-changed** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **formatter(v: _*_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-select-invoker",
      "description": "LionSelectInvoker: invoker button consuming a selected element\n\n\n---\n\n\n\n\n### **Methods:**\n - **_noSelectionTemplate(): _TemplateResult_** - To be overriden for a placeholder, used when `hasNoDefaultSelected` is true on the select rich\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-select-rich",
      "description": "LionSelectRich: wraps the <lion-listbox> element\n\n\n---\n\n\n\n\n### **Events:**\n - **blur** - undefined\n- **opened-changed** - undefined\n- **model-value-changed** - undefined\n- **form-element-name-changed** - undefined\n- **focus** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_getCheckedElements()** - In the select disabled options are still going to a possible value for example\nwhen prefilling or programmatically setting it.\n- **_noDefaultSelectedInheritsWidth()** - With no selected element, we should override the inheritsReferenceWidth in most cases.\nBy default, we will set it to 'min', and then set it back to what it was initially when\nsomething is selected.\nAs a subclasser you can override this behavior.\n- **_alignInvokerWidth()** - Align invoker width with content width\nMake sure display is not set to \"none\" while calculating the content width\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)\n- **setCheckedIndex(index: _number|number[]_)** - If an array is passed for multiple-choice, it will check the indexes in array, and uncheck the rest\nIf a number is passed, the item with the passed index is checked without unchecking others\nFor single choice, __onChildCheckedChanged we ensure that we uncheck siblings\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onListboxContentChanged()** - A Subclasser can perform additional logic whenever the elements inside the listbox are\nupdated. For instance, when a combobox does server side autocomplete, we want to\nmatch highlighted parts client side.\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-step",
      "description": "`LionStep` is one of many in a LionSteps Controller\n\n\n---\n\n\n\n\n### **Events:**\n - **enter** - undefined\n- **leave** - undefined\n- **skip** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-steps",
      "description": "`LionSteps` is a controller for a multi step system.\n\n\n---\n\n\n\n\n### **Events:**\n - **transition** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "tagName",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-switch",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **render()** - Restore original render function from FormControlMixin.js\nAs it gets overwritten in ChoiceInputMixin\n- **_isEmpty(modelValue: _any_): _boolean_** - Override this function from ChoiceInputMixin.\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-switch-button",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **checked-changed** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-tabs",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **selected-changed** - undefined",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-textarea",
      "description": "LionTextarea: extension of lion-field with native input element in place and user friendly API\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **setTextareaMaxHeight()** - To support maxRows we need to set max-height of the textarea\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **_reflectBackFormattedValueToUser()** - Note: Overrides the implementation from FormatMixin\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(v: _*_, opts: _FormatOptions_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_onModelValueChanged(args: _{ modelValue: unknown; }[]_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-tooltip",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **opened-changed** - undefined\n\n### **Methods:**\n - **_defineOverlayConfig(): _OverlayConfig_** - Overrides arrow and keepTogether modifier to be enabled,\nand adds onCreate and onUpdate hooks to sync from popper state\n- **_setOpenedWithoutPropertyEffects(newOpened: _boolean_)** - When the opened state is changed by an Application Developer,cthe OverlayController is\nrequested to show/hide. It might happen that this request is not honoured\n(intercepted in before-hide for instance), so that we need to sync the controller state\nto this webcomponent again, preventing eternal loops.\n- **toggle()** - Toggles the overlay\n- **open()** - Shows the overlay\n- **close()** - Hides the overlay\n- **repositionOverlay()** - Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\nan opened combobox and the surrounding context changes (the space consumed by the textbox\nincreases vertically)",
      "attributes": [],
      "references": []
    },
    {
      "name": "p-board",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **_aggregateResults()** - Gets all selection menu data and creates an aggregated\n'_viewData' result.",
      "attributes": [],
      "references": []
    },
    {
      "name": "md-ripple",
      "description": "Material Design Ripple Element\n\n- should be placed in a 'positioned' context (having positon: (realtive/fixed/absolute))\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-validation-feedback",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "allow-custom-choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "multiple-custom-choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "multiple-allow-custom-choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **resetInteractionState()** - Resets all interaction states for all formElements\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **_showFeedbackConditionFor(type: _string_, meta: _object_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "choice-input-foo",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "choice-input-bar",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "choice-input-group",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **form-element-name-changed** - undefined\n- **model-value-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **_completeRegistration()** - Resolves the registrationComplete promise. Subclassers can delay if needed\n- **_getFromAllFormElementsFilter(el: _FormControl_, type: _string_): _boolean_** - A filter function which will exclude a form field when returning false\nBy default, exclude form fields which are disabled\n\nThe type is be passed as well for more fine grained control, e.g.\ndistinguish the filter when fetching modelValue versus serializedValue\n- **_getFromAllFormElements(property: _string_, filterFn: _(el: FormControl, property?: string) => boolean_): _{[name:string]: any}_** - Implicit :( @override for FormGroupMixin, as choice fields \"fieldsets\"\nwill always implement both mixins\n\nTODO: Consider making this explicit by extracting this method to its own mixin and\nusing it in both FormGroupMixin and ChoiceGroupMixin, then override it here\nThis also makes it more DRY as we have same method with similar implementation\nin FormGroupMixin. I (@jorenbroekema) think the abstraction is worth it here..\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for Required validation and computation of interaction states\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost & ChoiceInputHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **_onRequestToAddFormElement(ev: _CustomEvent_)** - Hook for Subclassers to perform logic before an element is added\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **submitGroup()** - Handles interaction state 'submitted'.\nThis allows children to enable visibility of validation feedback\n- **resetGroup()** - Resets to initial/prefilled values and interaction states of all FormControls in group,\n- **clearGroup()** - Clears all values and resets all interaction states of all FormControls in group,\n- **_setValueForAllFormElements(property: _string | number_, value: _any_)** - Sets the same value for requested property in all formElements\n- **_setValueMapForAllFormElements(property: _string_, values: _{ [x: string]: any; }_)** - Allows to set formElements values via a keyed object structure\n- **_anyFormElementHas(property: _string_)** - Returns true when one of the formElements has requested\n- **_everyFormElementHas(property: _string_)** - Returns true when all of the formElements have requested property\n- **__onChildValidatePerformed(ev: _Event_)** - Gets triggered by event 'validate-performed' which enabled us to handle 2 different situations\n - react on modelValue change, which says something about the validity as a whole\n (at least two checkboxes for instance) and nothing about the children's values\n - children validity states have changed, so fieldset needs to update itself based on that\n- **__storeAllDescriptionElementsInParentChain()** - Traverses the _parentFormGroup tree, and gathers all aria description elements\n(feedback and helptext) that should be provided to children.\n\nIn the example below, when the input for 'street' has focus, a screenreader user\nwould hear the #group-error.\nIn case one of the inputs was in error state as well, the SR user would\nfirst hear the local error, followed by #group-error\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **render()** - Default Render Result:\n<div class=\"form-field__group-one\">\n  <div class=\"form-field__label\">\n    <slot name=\"label\"></slot>\n  </div>\n  <small class=\"form-field__help-text\">\n    <slot name=\"help-text\"></slot>\n  </small>\n</div>\n<div class=\"form-field__group-two\">\n  <div class=\"input-group\">\n    <div class=\"input-group__before\">\n      <slot name=\"before\"></slot>\n    </div>\n    <div class=\"input-group__container\">\n      <div class=\"input-group__prefix\">\n        <slot name=\"prefix\"></slot>\n      </div>\n      <div class=\"input-group__input\">\n        <slot name=\"input\"></slot>\n      </div>\n      <div class=\"input-group__suffix\">\n        <slot name=\"suffix\"></slot>\n      </div>\n    </div>\n    <div class=\"input-group__after\">\n      <slot name=\"after\"></slot>\n    </div>\n  </div>\n  <div class=\"form-field__feedback\">\n    <slot name=\"feedback\"></slot>\n  </div>\n</div>\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected",
      "attributes": [],
      "references": []
    },
    {
      "name": "custom-choice-input",
      "description": "\n\n\n---\n\n\n\n\n### **Events:**\n - **model-value-changed** - undefined\n- **user-input-changed** - undefined\n- **focus** - undefined\n- **blur** - undefined\n- **focusin** - undefined\n- **focusout** - undefined\n- **form-element-name-changed** - undefined\n- **form-element-register** - undefined\n- **touched-changed** - undefined\n- **dirty-changed** - undefined\n- **showsFeedbackForChanged** - undefined\n- **undefined** - undefined\n- **shouldShowFeedbackForChanged** - undefined\n- **validate-performed** - private event that should be listened to by LionFieldSet\n\n### **Methods:**\n - **firstUpdated(changedProperties: _PropertyValues_)** - Empty pending queue in order to guarantee order independence\n- **render()** - Template for [input=radio] and [input=checkbox] wrappers.\nFor [role=option] extensions, please override completely\n- **_preventDuplicateLabelClick(ev: _Event_)** - The native platform fires an event for both the click on the label, and also\nthe redispatched click on the native input element.\nThis results in two click events arriving at the host, but we only want one.\nThis method prevents the duplicate click and ensures the correct isTrusted event\nwith the correct event.target arrives at the host.\n- **_syncNameToParentFormGroup()** - Override this in case of extending ChoiceInputMixin and requiring\nto sync differently with parent form group name\nRight now it checks tag name match where the parent form group tagname\nshould include the child field tagname ('checkbox' is included in 'checkbox-group')\n- **_proxyInputEvent()** - This can be called whenever the view value should be updated. Dependent on component type\n(\"input\" for <input> or \"change\" for <select>(mainly for IE)) a different event should be\nused  as source for the \"user-input-changed\" event (which can be seen as an abstraction\nlayer on top of other events (input, change, whatever))\n- **_onModelValueChanged({ modelValue }, old: _{ modelValue:unknown }_, newV: _{ modelValue:unknown }_)** - Responds to modelValue changes in the synchronous cycle (most subclassers should listen to\nthe asynchronous cycle ('modelValue' in the .updated lifecycle))\n- **parser(v: _string_, opts: _FormatOptions_): _*_** - Converts viewValue to modelValue\nFor instance, a localized date to a Date Object\n- **formatter(modelValue: _ChoiceInputModelValue_): _string_** - Converts modelValue to formattedValue (formattedValue will be synced with\n`._inputNode.value`)\nFor instance, a Date object to a localized date.\n- **clear()** - Clears modelValue.\nInteraction states are not cleared (use resetInteractionState for this)\n- **_isEmpty(modelValue: _any_): _boolean_** - Used for required validator.\n- **_syncValueUpwards()** - Synchronization from `._inputNode.value` to `LionField` (flow [2])\nDownwards syncing should only happen for `LionField`.value changes from 'above'.\nThis triggers _onModelValueChanged and connects user input\nto the parsing/formatting/serializing loop.\n- **preprocessor(v: _string_, opts: _FormatOptions & { prevViewValue: string; currentCaretIndex: number }_): _{ viewValue:string; caretIndex:number; }|string|undefined_** - Preprocessors could be considered 'live formatters'. Their result is shown to the user\non keyup instead of after blurring the field. The biggest difference between preprocessors\nand formatters is their moment of execution: preprocessors are run before modelValue is\ncomputed (and work based on view value), whereas formatters are run after the parser (and\nare based on modelValue)\nAutomatically formats code while typing. It depends on a preprocessro that smartly\nupdates the viewValue and caret position for best UX.\n- **serializer(v: _?_): _string_** - Converts `.modelValue` to `.serializedValue`\nFor instance, a Date object to an iso formatted date string\n- **deserializer(v: _?_): _?_** - Converts `.serializedValue` to `.modelValue`\nFor instance, an iso formatted date string to a Date object\n- **_calculateValues({ source }, config: _{source:'model'|'serialized'|'formatted'|null}_)** - Responsible for storing all representations(modelValue, serializedValue, formattedValue\nand value) of the input value. Prevents infinite loops, so all value observers can be\ntreated like they will only be called once, without indirectly calling other observers.\n(in fact, some are called twice, but the __preventRecursiveTrigger lock prevents the\nsecond call from having effect).\n- **_dispatchModelValueChangedEvent(args: _{ modelValue: unknown; }[]_)** - This is wrapped in a distinct method, so that parents can control when the changed event\nis fired. For objects, a deep comparison might be needed.\n- **_reflectBackFormattedValueToUser()** - Synchronization from `LionField.value` to `._inputNode.value`\n- flow [1] will always be reflected back\n- flow [2] will not be reflected back when this flow was triggered via\n  `@user-input-changed` (this will happen later, when `formatOn` condition is met)\n- **_reflectBackOn(): _boolean_** - Every time .formattedValue is attempted to sync to the view value (on change/blur and on\nmodelValue change), this condition is checked. When enhancing it, it's recommended to\ncall via `return this._myExtraCondition && super._reflectBackOn()`\n- **_setValueAndPreserveCaret(newValue: _string_)** - Restores the cursor to its original position after updating the value.\n- **focus()** - Calls `focus()` on focusable element within\n- **blur()** - Calls `blur()` on focusable element within\n- **_enhanceLightDomA11yForAdditionalSlots(additionalSlots: _string[]_)** - Enhances additional slots(prefix, suffix, before, after) defined by developer.\n\nWhen boolean attribute data-label or data-description is found,\nthe slot element will be connected to the input via aria-labelledby or aria-describedby\n- **__reflectAriaAttr(attrName: _string_, nodes: _Element[]_, reorder: _boolean|undefined_)** - Will handle help text, validation feedback and character counter,\nprefix/suffix/before/after (if they contain data-description flag attr).\nAlso, contents of id references that will be put in the <lion-field>._ariaDescribedby property\nfrom an external context, will be read by a screen reader.\n- **_getAriaDescriptionElements(): _Array.<HTMLElement>_** - This function exposes descripion elements that a FormGroup should expose to its\nchildren. See FormGroupMixin.__getAllDescriptionElementsInParentChain()\n- **addToAriaLabelledBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add extra element references to aria-labelledby attribute.\n- **removeFromAriaLabelledBy(element: _HTMLElement_)** - Allows to remove element references from aria-labelledby attribute.\n- **addToAriaDescribedBy(element: _HTMLElement_, { idPrefix = '', reorder = true }, customConfig: _{idPrefix?:string; reorder?: boolean}_)** - Allows to add element references to aria-describedby attribute.\n- **removeFromAriaDescribedBy(element: _HTMLElement_)** - Allows to remove element references from aria-describedby attribute.\n- **_onBeforeRepropagateChildrenValues(ev: _CustomEvent_)** - Hook for Subclassers to add logic before repropagation\n- **_repropagationCondition(target: _FormControlHost_)** - Based on provided target, this condition determines whether received model-value-changed\nevent should be repropagated\n- **update(changedProperties: _PropertyValues_)** - Here we rerender slots defined with a `SlotRerenderObject`\n- **__initSlots(slotNames: _string[]_)** - Here we look what's inside our `get slots`.\nRerenderable slots get scheduled and \"one time slots\" get rendered once on connected\n- **initInteractionState()** - Evaluations performed on connectedCallback.\nThis method is public, so it can be called at a later moment (when we need to wait for\nregistering children for instance) as well.\nSince this method will be called twice in last mentioned scenario, it must stay idempotent.\n- **_iStateOnLeave()** - Sets touched value to true and reevaluates prefilled state.\nWhen false, on next interaction, user will start with a clean state.\n- **_iStateOnValueChange()** - Sets dirty value and validates when already touched or invalid\n- **resetInteractionState()** - Resets touched and dirty, and recomputes prefilled\n- **_onTouchedChanged()** - Dispatches event on touched state change\n- **_onDirtyChanged()** - Dispatches event on touched state change\n- **_showFeedbackConditionFor(type: _string_, meta: _InteractionStates_)** - Default feedbackCondition condition, used by Subclassers, that will be used when\n`feedbackCondition()` is not overridden by Application Developer.\nShow the validity feedback when returning true, don't show when false\n- **updateSync(name: _string_, oldValue: _?_)** - An abstraction that has the exact same api as `requestUpdate`, but taking\ninto account:\n- [member order independence](https://github.com/webcomponents/gold-standard/wiki/Member-Order-Independence)\n- property effects start when all (light) dom has initialized (on firstUpdated)\n- property effects don't interrupt the first meaningful paint\n- compatible with propertyAccessor.`hasChanged`: no manual checks needed or accidentally\nrun property effects / events when no change happened\neffects when values didn't change\nAll code previously present in requestUpdate can be placed in this method.\n- **validate({ clearCurrentResult = false }, opts: _{ clearCurrentResult?: boolean }_)** - Triggered by:\n - modelValue change\n - change in the 'validators' array\n - change in the config of an individual Validator\n\nThree situations are handled:\n- a1) the FormControl is empty: further execution is halted. When the Required Validator\n(being mutually exclusive to the other Validators) is applied, it will end up in the\nvalidation result (as the only Validator, since further execution was halted).\n- a2) there are synchronous Validators: this is the most common flow. When modelValue hasn't\nchanged since last async results were generated, 'sync results' are merged with the\n'async results'.\n- a3) there are asynchronous Validators: for instance when server side evaluation is needed.\nExecutions are scheduled and awaited and the 'async results' are merged with the\n'sync results'.\n\n- b) there are MetaValidators. After steps a1, a2, or a3 are finished, the holistic\nMetaValidators (evaluating the total result of the 'regular' (a1, a2 and a3) validators)\nwill be run...\n\nSituations a2 and a3 are not mutually exclusive and can be triggered within one `validate()`\ncall. Situation b will occur after every call.\n- **_updateFeedbackComponent()** - Responsible for retrieving messages from Validators and\n(delegation of) rendering them.\n\nFor `._feedbackNode` (extension of LionValidationFeedback):\n- retrieve messages from highest prio Validators\n- provide the result to custom feedback node and let the\ncustom node decide on their renderings\n\nIn both cases:\n- we compute the 'show' flag (like 'hasErrorVisible') for all types\n- we set the customValidity message of the highest prio Validator\n- we set aria-invalid=\"true\" in case hasErrorVisible is true\n- **feedbackCondition(type: _string_, meta: _object_, currentCondition: _((type: string, meta: object) => boolean)_): _boolean_** - Allows the Application Developer to specify when a feedback message should be shown\n- **_hasFeedbackVisibleFor(type: _string_)** - Used to translate `.hasFeedbackFor` and `.shouldShowFeedbackFor` to `.showsFeedbackFor`\n- **_prioritizeAndFilterFeedback({ validationResult }, opts: _{ validationResult: Validator[] }_): _Validator[]_** - Orders all active validators in this.__validationResult.\nCan also filter out occurrences (based on interaction states)\n- **defineScopedElement(tagName: _string_, klass: _typeof HTMLElement_)** - Defines a scoped element.\n- **reset()** - Resets modelValue to initial value.\nInteraction states are cleared\n- **_onChange(ev: _Event=_)** - Dispatches custom bubble event",
      "attributes": [],
      "references": []
    },
    {
      "name": "umbrella-form",
      "description": "\n\n\n---\n\n\n\n\n### **Methods:**\n - **waitForAllChildrenUpdates()** - Prevents errors outside test from being thrown",
      "attributes": [],
      "references": []
    },
    {
      "name": "element-b",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-a",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-b",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-a",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-b",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-a",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "page-b",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "my-component",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "p-table",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "on-the-fly",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "extended-comp",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "ref-class",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-checkbox",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-checkbox-group",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    },
    {
      "name": "lion-checkbox-indeterminate",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-accordion",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": []
    },
    {
      "name": "lion-button",
      "description": "\n\n\n---\n\n\n",
      "attributes": [],
      "references": [null]
    }
  ]
}
